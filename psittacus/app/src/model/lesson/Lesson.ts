import { getProposition, Proposition } from '../proposition/Proposition'
import { LessonData, Metadata } from './LessonBuilder'
import { LessonProgressData } from '../UserProgress'
import { Context } from '../Context'

export interface Lesson {
    next(): void
    getCurrent(): Proposition
    isOver(): boolean
    getScore(): number
    getId(): string
    dumpScores(): LessonProgressData
    cacheLesson(): Promise<void>
    saveScore(): void
    getExplaination(): string
    getPropositions(): Proposition[]
}

export function getLesson(data: LessonData, context: Context): Lesson {
    return new BaseLesson(data, context)
}

/**
 * A lesson contains a list of Propositions.
 * The constructor takes the json generated by `LessonBuilder`.
 */
class BaseLesson implements Lesson {

    readonly explanationText = this.data.explanation.text
    readonly metadata = this.data.metadata
    readonly propositions = this.data.propositions.map(p => getProposition(p, this.context))
    readonly scheduler = this.context.propoSchedFac.get(this)

    constructor(
        readonly data: LessonData,
        readonly context: Context,
    ) {
    }

    /**
     * Point to the next proposition.
     */
    next() {
        this.scheduler.next()
    }

    /**
     * Get the current Proposition.
     */
    getCurrent() {
        return this.scheduler.getCurrent()
    }

    /**
     * Is this lesson over yet?
     */
    isOver() {
        const over = this.scheduler.isOver()

        if (over) { //if this lesson is over, save the score and cache the lesson
            this.saveScore()
            this.cacheLesson()
        }

        return over
    }

    saveScore(): void {
        this.context?.UP.saveLessonScore(this.getId(), this.dumpScores())
    }

    /**
     * Get Lesson's overall score.
     */
    getScore() {
        return parseInt((this.propositions.map((p) => p.getScore()).reduce((a, b) => a + b) / this.propositions.length) + '')
    }

    /**
     * Nominally identifies a Lesson.
     */
    getId() {
        return `author=${this.metadata.author};target_language=${this.metadata.target_language};source_language=${this.metadata.source_language};title=${this.metadata.title};`
    }

    /**
    * Dumps info relative to the user's performance with this Lesson.
    */
    dumpScores(): LessonProgressData {

        return {
            last_taken: new Date().getTime(),
            overall: this.getScore(),
            propositions: this.propositions.map(p => [p.getHash(), p.getScore()]),
            lessonId: this.getId()
        }

    }

    /**
     * Cache this Lesson, overwriting it in case of conflicting ids.
     */
    async cacheLesson() {

        this.context?.db.delete('cachedLessons', this.getId())

        this.context?.db.add('cachedLessons', {
            id: this.getId(),
            lesson: this.data,
        })

    }

    getExplaination(): string {
        return this.explanationText
    }

    getPropositions(): Proposition[] {
        return this.propositions
    }

}


/**
 * Parses a Lesson id
 */
export function parseId(lessonId: string): Metadata {
    return Object.fromEntries(lessonId.split(";").filter(x => !!x).map(x => x.split("=")))
}

/**
 * Load a previously cached Lesson on the DB back into memory. 
 */
export async function getCachedLessonById(id: string, context: Context) {
    const record = await context.db.get('cachedLessons', id)
    return getLesson(record.lesson, context)
}

/**
 * Check if the id of a Lesson matches a certain category of Lessons.
 */
export function isMetadataMatching(lessonId: string, metadataFilter: Metadata) {

    const metadata = parseId(lessonId)

    return (
        ((metadataFilter.author || metadata.author) == metadata.author) &&
        ((metadataFilter.source_language || metadata.source_language) == metadata.source_language) &&
        ((metadataFilter.target_language || metadata.target_language) == metadata.target_language) &&
        ((metadataFilter.title || metadata.title) == metadata.title)
    )

}

/**
* Retrieve the ids of the lessons in history, with optional filtering on their metadata.
*/
export function getLessonIdsHistory(context: Context, metadataFilter?: Metadata) {

    let ids = context.UP.lessonScores().map(l => l.lessonId)

    if (metadataFilter) {
        return ids.filter(id => isMetadataMatching(id, metadataFilter))
    }

    return ids
}
